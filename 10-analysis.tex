\chapter{Введение в RPC}

\section{Удаленный вызов процедур}

RPC - это процесс, при котором программа на одной машине вызывает выполнение процедуры на другой, которая находится в другом адресном пространстве \cite{ibm-rpc}. 

Для доставки (или получения) данных реализации RPC в качестве транспорта используют UDP \cite{udp-info}, TCP \cite{tcp-info} или HTTP \cite{http-info} протоколы.

Отсутствие конкретного протокола связано с тем, что RPC не строго специфизированный протокол. Реализации отличаются между собой, но сам принцип остается прежним.  

На рисунке \ref{img:rpc-flow} представлены компоненты взаимодействия клиента и сервера при RPC вызове. 
\imgw{rpc-flow}{h!}{0.8\textwidth}{Процесс взаимодействия клиента и сервера при RPC}

С точки зрения удаленного вызова вызывающая программа известна как клиент, а вызываемая ею — как сервер.

Рассмотрим, как выполняется RPC вызов \cite{rpc-flow}.  

\begin{itemize}
\item Клиент вызывает процедуру-обертку клиента (stub), передавая параметры обычным способом. 
\item Клиентская обертка находится в собственном адресном пространстве и упаковывает параметры в стандартный формат, копируя каждый параметр в сообщение. 
\item Клиентская обертка упаковывает параметры в сообщение и передает на транспортный уровень, который отправляет его на удаленный сервер.
\item На сервере транспортный уровень передает сообщение серверной обертке, которая демаршалирует (распаковывает) параметры и вызывает нужную серверную процедуру, используя обычный механизм вызова процедур. 
\item Когда серверная процедура завершается, она возвращается к серверной обертке (например, через обычный вызов процедуры return), которая упорядочивает возвращаемые значения в сообщение. Затем обертка сервера передает сообщение транспортному уровню. 
\item Транспортный уровень отправляет сообщение с результатом обратно на клиентский транспортный уровень, который возвращает сообщение клиентской обертке. 
\item Клиентская обертка демаршалирует возвращаемые параметры, и выполнение возвращается к вызывающей стороне.
\end{itemize}

\clearpage
\section{Маршалинг}

Во время RPC вызова клиент маршалирует сообщение, сервер - демаршалирует.
На этом этапе проиходит упаковка в сообщение параметров, которые передаются в процедуру для передачи в другое адресное пространство.

Маршалинг и сериализация используются как синонимы, но есть несколько отличий \cite{marshal-vs-serialize}.

Маршалинг описывает процесс передачи объекта от клиента к серверу. 

Во время маршалинга сохраняется информация о пользовательских типах данных и сериализованные данные.

Сериализация касается только перевод объекта в поток байтов в двоичном формате.

Таким образом, сериализация является частью маршалинга.

\chapter{Форматы сериализации}

\section{Форматы сериализации данных и критерии сравнения}

В RPC используются несколько форматов передачи данных по сети.
Самые популярные построены на базе JSON \cite{json-info}.
В работе предлагается сравнить некоторые из них:
\begin{itemize}
\item JSON;
\item JSON+GZIP;
\item CBOR;
\item BSON;
\item MessagePack;
\item Protobuf.
\end{itemize}
\newpage
Для сравнения форматов следует выделить критерии.

Такими являются:
\begin{itemize}
\item максимальная вложенность;
\item нумерация полей;
\item эффективность компрессии данных (размер сериализованных DTO \cite{dto-info});
\item latency маршалинга/анмаршалинга (время, затрачиваемое на сериализацию);
\item возможность работы из различных языков (Go, Python);
\item поддержка версионности/эволюционирования структуры данных.
\end{itemize}

Следует использовать при сравнении структуры разного размера. Также протестировать структуры с большой вложенностью, чтобы выявить ограничения форматов.

На таблице \ref{tb:const-characters} описаны постоянные критерии форматов сериализации.  

\captionsetup[table]{justification=raggedleft,singlelinecheck=off}
\begin{landscape}
\label{tb:const-characters}
\begin{longtable}{|c|c|c|c|c|l|}
\caption{Сравнительная таблица форматов} \\
\hline
\textbf{Формат}      & \textbf{Бинарный} & \textbf{Макс. вложенность} & \textbf{Нумерация полей} & \textbf{Версионность} & \textbf{Языки}  \\ 
\hline
\textbf{BSON}        & Да                 & 65535                       & Нет                      & Да                    & Go,Python       \\ 
\hline
\textbf{CBOR}        & Да                 & Размер стека                & Нет                      & Да                    & Go,Python       \\ 
\hline
\textbf{JSON-RPC}    & Да                 & 10000                       & Нет                      & Да                    & Go,Python       \\ 
\hline
\textbf{MessagePack} & Да                 & Размер стека                & Нет                      & Да                    & Go,Python       \\ 
\hline
\textbf{Protobuf}    & Да                 & 100*                        & Да                       & Ytn                    & Go,Python       \\ 
\hline
\textbf{XML-RPC}     & Нет                & 10000                       & Нет                      & Да                    & Go,Python       \\
\hline
\end{longtable}
\end{landscape}

По описанным характеристикам серьезных отличий у форматов нет.
Поэтому следует сравнить непостоянные характеристики.  

Для этого необходимо собрать тестовые данные и реализовать бенчмарки, позволяющие замерить:
\begin{itemize}
\item размер сериализованных данных через пропускную способность;
\item время, затрачиваемое на сериализацию;
\end{itemize}

\clearpage

\section{Технические характеристики}
Исследование проводилось с использованием одного компьютера.
Его технические характеристики:
\begin{itemize}
	\item процессор: Apple M1 Pro;
	\item память: 32~Гб;
	\item операционная система: macOS~Monterey \cite{monterey} 12.4.
\end{itemize}

\section{Бенчмарки для форматов сериализации и результаты}

Для каждого формата сериализации есть два бенчмарка: для маршалинга и анмаршалинга.

Бенчмарки реализованы на языках программирования Go и Python3.  

Таблицы ниже состоят из четырех столбцов:
\begin{enumerate}
\item Название формата.
\item $NS/op$ - это среднее время выполнения каждого вызова функции в наносекундах.
\item $MB/s$ - это пропускная способность в мегабайтах;
\item $B/op$ - это число байт, выделяемых за операцию.
\end{enumerate}
\clearpage

\subsection{Используемые формулы}
NS/op рассчитывается по формуле:
\begin{equation}
\frac{T}{N},
\end{equation}
где $T$ - время выполнения функции в наносекундах, а $N$ - количество иттераций.


MB/s рассчитывается, как:
\begin{equation}
\frac{B \cdot N}{T \cdot C},
\end{equation}
где $B$ - выделяемое память в байтах на одной иттерации, $N$ - общее число иттераций, $T$ - время в секундах, $C$ - константа, равная $1e-6$.

B/op рассчитывается, как:
\begin{equation}
\dfrac{M_{b}}{N},
\end{equation}
где $M_{b}$ - общее число выделенных байт, за все иттерации бенмарка, $N$ - общее число иттераций.  

\subsection{Данные для бенчмарков}

Для бенчмарков было взято два вида данных. Для упрощения они именуются как данные типа А и типа Б.

Данные типа А - массив JSON весом 1.7 МБ, в каждом элементе массива используются строковые значения.  

Данные типа Б - массив JSON весом 120 КБ, в каждом элементе массива превалируют числовые значения: целые числа и числа с плавающей точкой.  

\clearpage
\subsection{Golang}

\begin{longtable}[ht!]{|l|c|c|l|} 
\caption{Бенчмарки маршалинга/анмаршалинга на golang с тестовыми данными А}
%\begin{tabular}{|l|c|c|l|} \\
\hline
\textbf{Формат}      & \textbf{Ns/op} & \textbf{MB/s} & \textbf{B/op}  \\ 
\hline
\multicolumn{4}{|c|}{Маршалинг}                                        \\ 
\hline
\textit{JSON}        & 1 947 565        & 551.08        & 1 109 587        \\ 
\hline
\textit{JSON+GZIP}   & 7 505 140        & 6.56          & 1 228 276        \\ 
\hline
\textit{JSON+ZSTD}   & 2 072 994        & 24.83         & 1 178 614        \\ 
\hline
\textit{CBOR}        & 3 773 309        & 209.15        & 376 789         \\ 
\hline
\textit{BSON}        & 6 719 164        & 182.56        & 2 599 949        \\ 
\hline
\textit{MessagePack} & 2 334 210        & 363.70        & 2 097 938        \\ 
\hline
\textit{Protobuf}    & 962 667         & 508.97        & 491 522         \\ 
\hline
\multicolumn{4}{|c|}{Анмаршалинг}                                      \\ 
\hline
\textit{JSON}        & 15 610 498       & 110.25        & 4 385 190        \\ 
\hline
\textit{JSON+GZIP}   & 16 417 442       & 3.45          & 1 001 751        \\ 
\hline
\textit{JSON+ZSTD}   & 15 325 713       & 3.65          & 1 220 576        \\ 
\hline
\textit{CBOR}        & 112 696         & 15097.51      & 1 705 460        \\ 
\hline
\textit{BSON}        & 10 002 288       & 122.65        & 4 582 385        \\ 
\hline
\textit{MessagePack} & 4 367 620        & 194.38        & 730 293         \\ 
\hline
\textit{Protobuf}    & 1 963 471        & 249.54        & 2 525 047        \\
\hline
%%\end{tabular}
\end{longtable}


\begin{table}[ht!]
\centering
\caption{Бенчмарки маршалинга на golang с тестовыми данными Б}
\begin{tabular}{|l|l|l|l|} 
\hline
\textbf{Формат}      & \textbf{Ns/op} & \textbf{MB/s} & \textbf{B/op}  \\ 
\hline
\multicolumn{4}{|c|}{Маршалинг}                                        \\ 
\hline
\textit{JSON}        & 199 762         & 461.77        & 125 136         \\ 
\hline
\textit{JSON+GZIP}   & 1 199 464        & 76.90         & 130 031         \\ 
\hline
\textit{JSON+ZSTD}   & 247 166         & 373.21        & 126 482         \\ 
\hline
\textit{CBOR}        & 78878          & 1008.31       & 98 403          \\ 
\hline
\textit{BSON}        & 218 095         & 515.15        & 119 181         \\ 
\hline
\textit{MessagePack} & 102 063         & 1092.18       & 261 500         \\ 
\hline
\textit{Protobuf}    & 103 150         & 666.70        & 73 728          \\ 
\hline
\multicolumn{4}{|c|}{Анмаршалинг}                                      \\ 
\hline
\textit{JSON}        & 686 517         & 146.93        & 217 785         \\ 
\hline
\textit{JSON+GZIP}   & 1 011 915        & 23.04         & 165 771         \\ 
\hline
\textit{JSON+ZSTD}   & 780 738         & 29.78         & 393 457         \\ 
\hline
\textit{CBOR}        & 10 321          & 9773.44       & 108 017         \\ 
\hline
\textit{BSON}        & 476 252         & 235.91        & 184 688         \\ 
\hline
\textit{MessagePack} & 93 540          & 1191.69       & 48             \\ 
\hline
\textit{Protobuf}    & 58 568          & 1174.20       & 152 241         \\
\hline
\end{tabular}
\end{table}


\clearpage

\subsection{Python}

\begin{table}[ht!]
\centering
\caption{Бенчмарки маршалинга на python 3 с тестовыми данными А}
\begin{tabular}{|l|l|l|l|} 
\hline
\textbf{Формат}      & \textbf{Ns/op} & \textbf{MB/s} & \textbf{B/op}  \\ 
\hline
\multicolumn{4}{|c|}{Маршалинг}                                        \\ 
\hline
\textit{JSON}        & 117 167 000      &    73.85         &    0.42 \\ 
\hline
\textit{JSON+GZIP}   & 21 087 000       &     0.1          &    0.87 \\ 
\hline
\textit{JSON+ZSTD}   & 3 121 000        &    6.1           &    16.5 \\ 
\hline
\textit{CBOR}        & 11 109 000       &    0.35           &   0.47 \\ 
\hline
\textit{BSON}        & 113 209 600      &    2.1           &    17.8    \\ 
\hline
\textit{MessagePack} & 3 316 000        &     18.2          &   27.6 \\ 
\hline
\textit{Protobuf}    & 8 167 000        &     0.78          &   0.36 \\ 
\hline
\multicolumn{4}{|c|}{Анмаршалинг}                                      \\ 
\hline
\textit{JSON}        & 20 241 000       &    0.12           &   0.02 \\ 
\hline
\textit{JSON+GZIP}   & 22 031 000       &    0.49           &   0.53 \\ 
\hline
\textit{JSON+ZSTD}   & 21 667 000       &     2.12          &   0.44 \\ 
\hline
\textit{CBOR}        & 33 624 000       &     17.3          &   12.1 \\ 
\hline
\textit{BSON}        & 105 822 000      &     1.1          &    10.5 \\ 
\hline
\textit{MessagePack} & 25 164 000       &     0.37          &   0.71 \\ 
\hline
\textit{Protobuf}    & 880 427         &     22.3           &   11.2 \\
\hline
\end{tabular}
\end{table}